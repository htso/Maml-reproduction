abs(E)[[1]]
}
sapply(1:5, function(n) {max.eig(n, 1)})
E = sapply(1:10000, function(n) {max.eig(5, 1)})
summary(E)
sapply(1:5, function(n) {max.eig(n, 1)})
sapply(1:5, function(n) {sapply(1:3, function(m) {max.eig(n, m)})})
library(foreach)
times(10) %do% max.eig(5, 1)
foreach(n = 1:5) %do% max.eig(n, 1)
foreach(n = 1:5, .combine = c) %do% max.eig(n, 1)
foreach(n = 1:5) %:% foreach(m = 1:3) %do% max.eig(n, m)
foreach(n = 1:5) %dopar% max.eig(n, 1)
library(doMC)
install.packages("doMC")
library(doMC)
registerDoMC(cores=3)
library(rbenchmark)
install.packages("rbenchmark")
library(rbenchmark)
benchmark(
foreach(n = 1:50) %do% max.eig(n, 1),
foreach(n = 1:50) %dopar% max.eig(n, 1)
)
library(doSNOW)
cluster = makeCluster(3, type = "SOCK")
registerDoSNOW(cluster)
benchmark(
foreach(n = 1:50) %do% max.eig(n, 1),
foreach(n = 1:50) %dopar% max.eig(n, 1)
)
stopCluster(cluster)
cluster = makeCluster(20, type = "MPI")
registerDoSNOW(cluster)
benchmark(
foreach(n = 1:50) %do% max.eig(n, 1),
foreach(n = 1:50) %dopar% max.eig(n, 1)
)
# ================== UNIT TESTS ===================================================================
library(Adma)
library(TTR)
# Show.changes.over.iter
nm = "/media/rspace/WanChai/Dropbox/TSOTHOUGHTS/AdaptiveMAStrategy/Crossover/DE-Xo-rollforw-Reg=L0-2018-03-19-13:09:18.RData"
load(nm)
parit = sol[[1]]$member$bestmemit
head9parit
head(parit)
train.ix = which(yr >= 1990 & yr <= 1995)
test.ix = which(yr >= 1996  & yr <= 1997)
xt = x[train.ix]
len(xt)
length(ix)
length(xt)
res = Show.changes.over.iter(parit, xt, Xover.profile)
Fun = Xover.profile
res = Show.changes.over.iter(parit, xt, Fun)
prof = Fun(w=parit[1,], xt)
str(prof)
pos = matrix(NA, nrow=nrow(parit), ncol=5)
colnames(pos) = c("open.t", "close.t", "ret.tr", "delta.tr", "len.tr")
pos[,"open.t"] = prof$position.open
pos[,"close.t"] = prof$position.close
pos[,"ret.tr"] = prof$ret.tr
pos = matrix(NA, nrow=nrow(prof$ret.tr), ncol=5)
colnames(pos) = c("open.t", "close.t", "ret.tr", "delta.tr", "len.tr")
pos = matrix(NA, nrow=length(prof$ret.tr), ncol=5)
colnames(pos) = c("open.t", "close.t", "ret.tr", "delta.tr", "len.tr")
pos[,"open.t"] = prof$position.open
pos[,"close.t"] = prof$position.close
pos[,"ret.tr"] = prof$ret.tr
pos[,"delta.tr"] = prof$delta.tr
pos[,"len.tr"] = prof$len.tr
head(pos)
res = changes.in.trades(pos1, pos)
prof1 = Fun(w=parit[2,], xt)
pos1 = matrix(NA, nrow=length(prof1$ret.tr), ncol=5)
colnames(pos1) = c("open.t", "close.t", "ret.tr", "delta.tr", "len.tr")
pos1[,"open.t"] = prof1$position.open
pos1[,"close.t"] = prof1$position.close
pos1[,"ret.tr"] = prof1$ret.tr
pos1[,"delta.tr"] = prof1$delta.tr
pos1[,"len.tr"] = prof1$len.tr
res = changes.in.trades(pos1, pos)
str(res)
mat = res$mat
head(mat, 30)
head(mat, 30)
head(mat, 30)
# sanity check
mat[,"len.tr.cur"] == mat[,"close.t.cur"] - mat[,"open.t"]
?all
# sanity check
all(mat[,"len.tr.cur"] == mat[,"close.t.cur"] - mat[,"open.t"], na.rm=TRUE)
all(mat[,"len.tr.prev"] == mat[,"close.t.prev"] - mat[,"open.t"], na.rm=TRUE)
sum(mat[,"delta.tr.cur"], na.rm=T)
sum(mat[,"delta.tr.prev"], na.rm=T)
sum(mat[,"delta.tr.cur"], na.rm=T)
ii = 2005
train.ix = which(ee$yr >= 1990 & ee$yr <= ii)
test.ix = which(ee$yr >= (ii+1) & ee$yr <= (ii+2) )
ii = 2005
train.ix = which(yr >= 1990 & yr <= ii)
test.ix = which(yr >= (ii+1) & yr <= (ii+2) )
xt = x[train.ix]
Fun = Xover.profile
prof = Fun(w=parit[1,], xt)
pos = matrix(NA, nrow=length(prof$ret.tr), ncol=5)
colnames(pos) = c("open.t", "close.t", "ret.tr", "delta.tr", "len.tr")
pos[,"open.t"] = prof$position.open
pos[,"close.t"] = prof$position.close
pos[,"ret.tr"] = prof$ret.tr
pos[,"delta.tr"] = prof$delta.tr
pos[,"len.tr"] = prof$len.tr
prof1 = Fun(w=parit[2,], xt)
pos1 = matrix(NA, nrow=length(prof1$ret.tr), ncol=5)
colnames(pos1) = c("open.t", "close.t", "ret.tr", "delta.tr", "len.tr")
pos1[,"open.t"] = prof1$position.open
pos1[,"close.t"] = prof1$position.close
pos1[,"ret.tr"] = prof1$ret.tr
pos1[,"delta.tr"] = prof1$delta.tr
pos1[,"len.tr"] = prof1$len.tr
res = changes.in.trades(pos1, pos)
mat = res$mat
# some sanity checks >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
all(mat[,"len.tr.cur"] == mat[,"close.t.cur"] - mat[,"open.t"], na.rm=TRUE)
all(mat[,"len.tr.prev"] == mat[,"close.t.prev"] - mat[,"open.t"], na.rm=TRUE)
sum(mat[,"delta.tr.cur"], na.rm=T)
sum(mat[,"delta.tr.prev"], na.rm=T)
mat
dim(mat)
head(mat, 100)
plot(mat[,"delta.tr.cur"], type="s", col="red")
par(new=TRUE)
plot(mat[,"delta.tr.prev"], type="s", col="blue")
plot(mat[,"delta.tr.cur"], type="s", col="red", ylim=c(-50, 150))
par(new=TRUE)
plot(mat[,"delta.tr.prev"], type="s", col="blue", ylim=c(-50, 150))
plot(mat[,"delta.tr.cur"], type="s", col="red", ylim=c(-50, 170))
par(new=TRUE)
plot(mat[,"delta.tr.prev"], type="s", col="blue", ylim=c(-50, 170))
par(mfrow=c(2,1), mar=c(1,1,1,1))
plot(mat[,"delta.tr.cur"], type="s", col="red", ylim=c(-50, 170))
plot(mat[,"delta.tr.prev"], type="s", col="blue", ylim=c(-50, 170))
par(mfrow=c(2,1), mar=c(1,1,1,1))
plot(mat[1:100,"delta.tr.cur"], type="s", col="red", ylim=c(-50, 170))
plot(mat[1:100,"delta.tr.prev"], type="s", col="blue", ylim=c(-50, 170))
par(mfrow=c(2,1), mar=c(1,1,1,1))
plot(mat[1:300,"delta.tr.cur"], type="s", col="red", ylim=c(-50, 170))
plot(mat[1:300,"delta.tr.prev"], type="s", col="blue", ylim=c(-50, 170))
par(mfrow=c(2,1), mar=c(1,1,1,1))
barplot(mat[1:300,"delta.tr.cur"],  col="red", ylim=c(-50, 170))
barplot(mat[1:300,"delta.tr.prev"], col="blue", ylim=c(-50, 170))
prof1 = Fun(w=parit[10,], xt)
pos1 = matrix(NA, nrow=length(prof1$ret.tr), ncol=5)
colnames(pos1) = c("open.t", "close.t", "ret.tr", "delta.tr", "len.tr")
pos1[,"open.t"] = prof1$position.open
pos1[,"close.t"] = prof1$position.close
pos1[,"ret.tr"] = prof1$ret.tr
pos1[,"delta.tr"] = prof1$delta.tr
pos1[,"len.tr"] = prof1$len.tr
res = changes.in.trades(pos1, pos)
mat = res$mat
# some sanity checks >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
all(mat[,"len.tr.cur"] == mat[,"close.t.cur"] - mat[,"open.t"], na.rm=TRUE)
all(mat[,"len.tr.prev"] == mat[,"close.t.prev"] - mat[,"open.t"], na.rm=TRUE)
sum(mat[,"delta.tr.cur"], na.rm=T)
sum(mat[,"delta.tr.prev"], na.rm=T)
(A = sum(mat[,"delta.tr.cur"], na.rm=T))
(B = sum(mat[,"delta.tr.prev"], na.rm=T))
par(mfrow=c(2,1), mar=c(1,1,1,1))
barplot(mat[1:300,"delta.tr.cur"],  col="red", ylim=c(-50, 170))
barplot(mat[1:300,"delta.tr.prev"], col="blue", ylim=c(-50, 170))
prof1 = Fun(w=parit[100,], xt)
pos1 = matrix(NA, nrow=length(prof1$ret.tr), ncol=5)
colnames(pos1) = c("open.t", "close.t", "ret.tr", "delta.tr", "len.tr")
pos1[,"open.t"] = prof1$position.open
pos1[,"close.t"] = prof1$position.close
pos1[,"ret.tr"] = prof1$ret.tr
pos1[,"delta.tr"] = prof1$delta.tr
pos1[,"len.tr"] = prof1$len.tr
res = changes.in.trades(pos1, pos)
mat = res$mat
# some sanity checks >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
all(mat[,"len.tr.cur"] == mat[,"close.t.cur"] - mat[,"open.t"], na.rm=TRUE)
all(mat[,"len.tr.prev"] == mat[,"close.t.prev"] - mat[,"open.t"], na.rm=TRUE)
(A = sum(mat[,"delta.tr.cur"], na.rm=T))
(B = sum(mat[,"delta.tr.prev"], na.rm=T))
par(mfrow=c(2,1), mar=c(1,1,1,1))
barplot(mat[1:300,"delta.tr.cur"],  col="red", ylim=c(-50, 170))
barplot(mat[1:300,"delta.tr.prev"], col="blue", ylim=c(-50, 170))
# plot the trades that are different
ix = which(mat[,"delta.tr.cur"] != mat[,"delta.tr.prev"])
len(ix)
length(ix)
library(goodies)
# plot the trades that are different
ix = which(mat[,"delta.tr.cur"] != mat[,"delta.tr.prev"])
par(mfrow=c(2,1), mar=c(1,1,1,1))
barplot(mat[ix,"delta.tr.cur"],  col="red", ylim=c(-50, 170))
barplot(mat[ix,"delta.tr.prev"], col="blue", ylim=c(-50, 170))
ix
mat[ix[1:10],]
viewer(mat)
Viewer(mat)
# plot the trades that are different betwn the two iterations
ix = which(mat[,"delta.tr.cur"] != mat[,"delta.tr.prev"] |
is.na(mat[,"delta.tr.cur"]) | is.na(mat[,"delta.tr.prev"]) )
len(ix)
par(mfrow=c(2,1), mar=c(1,1,1,1))
barplot(mat[ix,"delta.tr.cur"],  col="red", ylim=c(-50, 170))
barplot(mat[ix,"delta.tr.prev"], col="blue", ylim=c(-50, 170))
plot(cumsum(res$net.delta), type="s")
X11();plot(cumsum(res$net.delta), type="s")
str(res)
devtools::install_github("rstudio/keras")
library(devtools)
devtools::install_github("rstudio/keras")
options(download.file.method = "wget")
devtools::install_github("rstudio/keras")
x = seq(from=-5, to=5, by=0.1)
x
sin(x)
y = sin(x + 0.1*pi)*cos(x)
X11();plot(x,y)
y = sin(x + 0.5*pi)*cos(x)
X11();plot(x,y)
y = sin(0.5*x + 0.5*pi)*cos(x)
X11();plot(x,y)
?seq
amp.rng = c(0.1, 5.0)
ph.rng = c(0, pi)
x = seq(from=-5, to=5.0, by=0.1)
w1 = seq(from=0.1, to=3, length.out=4)
w2 = seq(from=0.1, to=3, length.out=4)
w1
w2
x
w1 = seq(from=0.1, to=3, length.out=5)
w2 = seq(from=0.1, to=3, length.out=5)
pi
ph1 = 0
ph2 = 0.5*pi
X11()
par(mfrow=c(5,5), mar=c(1,1,1,1))
for ( i in 1:5 ) {
for ( j in 1:5 ) {
y = sin(w1[i]*x + ph1) *  cos(w2[j]*x + ph2)
plot(x, y, type="l", col="red")
}
}
w1 = seq(from=0.1, to=3, length.out=5)
w2 = seq(from=1, to=5, length.out=5)
ph1 = 0
ph2 = 0.5*pi
X11()
par(mfrow=c(5,5), mar=c(1,1,1,1))
for ( i in 1:5 ) {
for ( j in 1:5 ) {
y = sin(w1[i]*x + ph1) *  cos(w2[j]*x + ph2)
plot(x, y, type="l", col="red")
}
}
?legend
?text
?mtext
X11()
par(mfrow=c(5,5), mar=c(1,1,1,1))
for ( i in 1:5 ) {
for ( j in 1:5 ) {
y = sin(w1[i]*x + ph1) *  cos(w2[j]*x + ph2)
plot(x, y, type="l", col="red")
mtext(paste("w1:", w1[i], " w2:", w2[j]), side=3, line=-1)
}
}
w1 = seq(from=0.1, to=3, length.out=5)
w2 = seq(from=1, to=5, length.out=5)
ph1 = 0.1*pi
ph2 = 0.5*pi
X11()
par(mfrow=c(5,5), mar=c(1,1,1,1))
for ( i in 1:5 ) {
for ( j in 1:5 ) {
y = sin(w1[i]*x + ph1) *  cos(w2[j]*x + ph2)
plot(x, y, type="l", col="red")
mtext(paste("w1:", w1[i], " w2:", w2[j]), side=3, line=-2)
}
}
w1 = seq(from=0.1, to=3, length.out=5)
w2 = seq(from=1, to=5, length.out=5)
ph1 = seq(from=0.1*pi, to=0.6*pi, length.out=5)
ph2 = seq(from=0.4*pi, to=0.9*pi, length.out=5)
x = seq(from=-5, to=5.0, by=0.1)
w1 = seq(from=0.1, to=3, length.out=5)
w2 = seq(from=1, to=5, length.out=5)
ph1 = seq(from=0.1*pi, to=0.6*pi, length.out=5)
ph2 = seq(from=0.4*pi, to=0.9*pi, length.out=5)
pdf("fun-shapes.pdf", width=11, height=8.5)
par(mfrow=c(2,2))
for ( i in 1:5 ) {
for ( j in 1:5 ) {
for ( k in 1:5 ) {
y = sin(w1[i]*x + ph1[k]) *  cos(w2[j]*x + ph2[k])
plot(x, y, type="l", col="red")
mtext(paste("w1:", w1[i], " w2:", w2[j], "ph1:", ph1[k], "ph2:", ph2[k]), side=3, line=-2)
}
}
}
dev.off()
getwd()
path = "/media/rspace/WanChai/Dropbox/TSOTHOUGHTS/Tensorflow-CODE"
setwd(path)
pdf("fun-shapes.pdf", width=11, height=8.5)
par(mfrow=c(2,2))
for ( i in 1:5 ) {
for ( j in 1:5 ) {
for ( k in 1:5 ) {
y = sin(w1[i]*x + ph1[k]) *  cos(w2[j]*x + ph2[k])
plot(x, y, type="l", col="red")
mtext(paste("w1:", w1[i], " w2:", w2[j], "ph1:", ph1[k], "ph2:", ph2[k]), side=3, line=-2)
}
}
}
dev.off()
getwd()
path = "/media/rspace/WanChai/Dropbox/TSOTHOUGHTS/Tensorflow-CODE/maml"
setwd(path)
pdf("fun-shapes.pdf", width=11, height=8.5)
par(mfrow=c(3,3), mar=c(2,2,2,2))
for ( i in 1:5 ) {
for ( j in 1:5 ) {
for ( k in 1:5 ) {
y = sin(w1[i]*x + ph1[k]) *  cos(w2[j]*x + ph2[k])
plot(x, y, type="l", col="red")
mtext(paste("w1:", w1[i], " w2:", w2[j], "ph1:", round(ph1[k],1), "ph2:", round(ph2[k],1)),
side=3, line=-2)
}
}
}
dev.off()
pdf("fun-shapes.pdf", width=11, height=8.5)
par(mfrow=c(3,4), mar=c(2,2,2,2))
for ( i in 1:5 ) {
for ( j in 1:5 ) {
for ( k in 1:5 ) {
y = sin(w1[i]*x + ph1[k]) *  cos(w2[j]*x + ph2[k])
plot(x, y, type="l", col="red")
mtext(paste("w1:", w1[i], " w2:", w2[j], "ph1:", round(ph1[k],1), "ph2:", round(ph2[k],1)),
side=3, line=-2)
}
}
}
dev.off()
?expand.grid
w1 = seq(from=0.1, to=3, length.out=5)
w2 = seq(from=1, to=5, length.out=5)
ph1 = seq(from=0.1*pi, to=0.6*pi, length.out=5)
ph2 = seq(from=0.4*pi, to=0.9*pi, length.out=5)
Grid = expand.grid(w1=w1, w2=w2, ph1=ph1, ph2=ph2)
dim(Grid)
head(Grid)
625/25
w1 = seq(from=0.1, to=3, length.out=5)
w2 = seq(from=1, to=5, length.out=5)
ph1 = seq(from=0.1*pi, to=0.6*pi, length.out=5)
ph2 = seq(from=0.4*pi, to=0.9*pi, length.out=5)
Grid = expand.grid(w1=w1, w2=w2, ph1=ph1, ph2=ph2)
dim(Grid)
pdf("fun-shapes.pdf", width=11, height=8.5)
par(mfrow=c(5,5), mar=c(2,2,2,2))
for ( i in 1:row(Grid) ) {
W1 = Grid[i, "w1"]
W2 = Grid[i, "w2"]
Ph1 = Grid[i, "ph1"]
Ph2 = Grid[i, "ph2"]
y = sin(W1*x + Ph1) * cos(W2*x + Ph2)
plot(x, y, type="l", col="red")
mtext(paste("w1:", W1, " w2:", W2, "ph1:", round(Ph1,1), "ph2:", round(Ph2,1)),
side=3, line=-2, cex=0.8)
}
dev.off()
row(Grid)
nrow(Grid)
pdf("fun-shapes.pdf", width=11, height=8.5)
par(mfrow=c(5,5), mar=c(2,2,2,2))
for ( i in 1:nrow(Grid) ) {
W1 = Grid[i, "w1"]
W2 = Grid[i, "w2"]
Ph1 = Grid[i, "ph1"]
Ph2 = Grid[i, "ph2"]
y = sin(W1*x + Ph1) * cos(W2*x + Ph2)
plot(x, y, type="l", col="red")
mtext(paste("w1:", W1, " w2:", W2, "ph1:", round(Ph1,1), "ph2:", round(Ph2,1)),
side=3, line=-2, cex=0.8)
}
dev.off()
pdf("fun-shapes.pdf", width=11, height=8.5)
par(mfrow=c(5,5), mar=c(2,2,2,2))
for ( i in 1:nrow(Grid) ) {
W1 = Grid[i, "w1"]
W2 = Grid[i, "w2"]
Ph1 = Grid[i, "ph1"]
Ph2 = Grid[i, "ph2"]
y = sin(W1*x + Ph1) * cos(W2*x + Ph2)
plot(x, y, type="l", col="red")
mtext(paste("w:", W1, " ", W2, "ph:", round(Ph1,1), " ", round(Ph2,1)),
side=3, line=-2, cex=0.8)
}
dev.off()
ix = which(Grid[,"w1"] == Grid[,"w2"])
len(ix)
length(ix)
ix
Grid = Grid[-ix,]
dim(Grid)
pdf("fun-shapes.pdf", width=11, height=8.5)
par(mfrow=c(5,5), mar=c(2,2,2,2))
for ( i in 1:nrow(Grid) ) {
W1 = Grid[i, "w1"]
W2 = Grid[i, "w2"]
Ph1 = Grid[i, "ph1"]
Ph2 = Grid[i, "ph2"]
y = sin(W1*x + Ph1) * cos(W2*x + Ph2)
plot(x, y, type="l", col="red")
mtext(paste("w:", W1, " ", W2, "ph:", round(Ph1,1), " ", round(Ph2,1)),
side=3, line=-2, cex=0.8)
}
dev.off()
w1 = seq(from=0.1, to=3, length.out=5)
w2 = seq(from=0.1, to=3, length.out=5)
ph1 = seq(from=0.1*pi, to=0.6*pi, length.out=5)
ph2 = seq(from=0.4*pi, to=0.9*pi, length.out=5)
Grid = expand.grid(w1=w1, w2=w2, ph1=ph1, ph2=ph2)
ix = which(Grid[,"w1"] == Grid[,"w2"])
Grid = Grid[-ix,]
dim(Grid)
pdf("fun-shapes.pdf", width=11, height=8.5)
par(mfrow=c(5,5), mar=c(2,2,2,2))
for ( i in 1:nrow(Grid) ) {
W1 = Grid[i, "w1"]
W2 = Grid[i, "w2"]
Ph1 = Grid[i, "ph1"]
Ph2 = Grid[i, "ph2"]
y = sin(W1*x + Ph1) * cos(W2*x + Ph2)
plot(x, y, type="l", col="red")
mtext(paste("w:", W1, " ", W2, "ph:", round(Ph1,1), " ", round(Ph2,1)),
side=3, line=-2, cex=0.8)
}
dev.off()
w1 = seq(from=0.1, to=2.5, length.out=4)
w2 = seq(from=0.1, to=2.5, length.out=4)
ph1 = seq(from=0.1*pi, to=0.6*pi, length.out=4)
ph2 = seq(from=0.4*pi, to=0.9*pi, length.out=4)
Grid = expand.grid(w1=w1, w2=w2, ph1=ph1, ph2=ph2)
ix = which(Grid[,"w1"] == Grid[,"w2"])
Grid = Grid[-ix,]
dim(Grid)
pdf("fun-shapes.pdf", width=11, height=8.5)
par(mfrow=c(5,5), mar=c(2,2,2,2))
for ( i in 1:nrow(Grid) ) {
W1 = Grid[i, "w1"]
W2 = Grid[i, "w2"]
Ph1 = Grid[i, "ph1"]
Ph2 = Grid[i, "ph2"]
y = sin(W1*x + Ph1) * cos(W2*x + Ph2)
plot(x, y, type="l", col="red")
mtext(paste("w:", W1, " ", W2, "ph:", round(Ph1,1), " ", round(Ph2,1)),
side=3, line=-2, cex=0.8)
}
dev.off()
x = seq(from=-5, to=5.0, by=0.1)
w1 = seq(from=0.1, to=2.5, length.out=4)
w2 = seq(from=0.1, to=2.5, length.out=4)
ph1 = seq(from=0.1*pi, to=0.6*pi, length.out=4)
ph2 = seq(from=0.4*pi, to=0.9*pi, length.out=4)
Grid = expand.grid(w1=w1, w2=w2, ph1=ph1, ph2=ph2)
dim(Grid)
ix = which(Grid[,"w1"] == Grid[,"w2"])
length(ix)
library(goodies)
library(doParallel)
library(foreach)
cl = makeCluster(3)
registerDoParallel(cl)
nr = 1000 # number of obs
nc = 1000 # dim
# Obs matrix
x = matrix(rnorm(nr*nc, mean=0, sd=1.0), nrow = nr, ncol=nc)
# euclidean distance
dmat = dist(x, method="euclidean", diag=FALSE, upper=TRUE)
mat = as.matrix(dmat)
diag(mat) <- NA
mat[upper.tri(mat)] <- NA
sd(as.vector(mat), na.rm=TRUE)
# Variance of distances as a function of dimension ==============
# That is, the concentration of points on the surface of a sphere
# as implied by theory.
pts.sd = 0.1
dim.v = 1000:2000
p = 2
# NOTE : takes > one hr to finish !!
res <- foreach ( i=dim.v[1]:dim.v[len(dim.v)], .combine=rbind ) %dopar%
{
x = matrix(rnorm(nr*i, mean=0, sd=pts.sd), nrow=nr, ncol=i)
mat = as.matrix(dist(x, method="minkowski", p=p))
diag(mat) <- NA
mat[upper.tri(mat)] <- NA
mean.dist = mean(as.vector(mat), na.rm=TRUE)
spread = sd(as.vector(mat), na.rm=TRUE)
c(mean.dist, spread)
}
colnames(res) = c("mean.dist", "spread")
dim(res)
